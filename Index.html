<!DOCTYPE html>
<html lang="lv">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>A-Frame + Spark + Extras</title>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/super-three@0.177.0/build/three.module.js",
          "aframe": "https://aframe.io/releases/1.7.1/aframe.module.min.js",
          "@sparkjsdev/spark": "https://sparkjs.dev/releases/spark/0.1.8/spark.module.js"
        }
      }
    </script>
  </head>

  <body>
    <div id="app"></div>
    
    <!-- Welcome Text -->
    <div id="welcome-text" style="
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 30px 40px;
      background: linear-gradient(135deg, rgba(44, 44, 44, 0.95) 0%, rgba(26, 26, 26, 0.95) 100%);
      color: white;
      border-radius: 10px;
      max-width: 400px;
      text-align: center;
      z-index: 900;
      font-family: Arial, sans-serif;
      font-size: 18px;
      font-weight: bold;
      line-height: 1.6;
      pointer-events: none;
    ">Vidzemes podnieka <br>Gustava Ozoliņa (1866–1942) <br>darbnīca</div>

    <!-- VR Button -->
    <button id="vr-button" style="
      position: fixed;
      bottom: 20px;
      right: 20px;
      padding: 15px 30px;
      font-size: 18px;
      background-color: #555555;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      z-index: 1000;
      font-weight: bold;
    ">Enter VR</button>

    <!-- Object Info Popup -->
    <div id="object-popup-overlay" style="
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      z-index: 9999;
      display: none;
    "></div>
    
    <div id="object-popup" style="
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);
      color: white;
      padding: 60px;
      border-radius: 20px;
      max-width: 700px;
      text-align: center;
      z-index: 10000;
      display: none;
      font-family: Arial, sans-serif;
      box-shadow: 0 0 80px rgba(76, 175, 80, 0.8), inset 0 0 40px rgba(76, 175, 80, 0.2);
      pointer-events: auto;
    ">
      <h2 id="object-title" style="margin: 0 0 30px 0; color: #4CAF50; font-size: 42px; font-weight: bold; text-shadow: 0 2px 10px rgba(0,0,0,0.8);"></h2>
      <p id="object-description" style="margin: 0 0 30px 0; line-height: 1.9; font-size: 22px; color: #e0e0e0;"></p>
      <p style="margin: 0; font-size: 14px; color: #888; font-style: italic;">(Release trigger to close)</p>
    </div>

    <script type="module">
      import AFRAME from "aframe";
      import { SplatMesh, SparkRenderer } from "@sparkjsdev/spark";

      // expose AFRAME globally for extras + physics
      window.AFRAME = AFRAME;

      // load aframe-extras AFTER AFRAME exists
      await new Promise((resolve) => {
        const s = document.createElement("script");
        s.src =
          "https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.6.1/dist/aframe-extras.min.js";
        s.onload = resolve;
        document.head.appendChild(s);
      });

      // Load VR popup banner component
      const bannerScript = document.createElement("script");
      bannerScript.src = "components/vr-popup-banner.js";
      document.head.appendChild(bannerScript);

      // Raycaster component for hand pointing
      AFRAME.registerComponent("hand-raycaster", {
        init() {
          const hand = this.el;
          let lastBanner = null;
          
          hand.addEventListener("triggerdown", () => {
            // Get camera position
            const camera = document.querySelector("[camera]");
            if (!camera) return;
            
            const cameraPos = new THREE.Vector3();
            camera.object3D.getWorldPosition(cameraPos);
            
            const handPos = new THREE.Vector3();
            hand.object3D.getWorldPosition(handPos);
            
            // Direction from camera to hand
            const direction = new THREE.Vector3().subVectors(handPos, cameraPos).normalize();
            
            const raycaster = new THREE.Raycaster(cameraPos, direction);
            const scene = hand.sceneEl.object3D;
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            // Find first banner in intersections
            for (let i = 0; i < intersects.length; i++) {
              const obj = intersects[i].object;
              
              // Find parent banner entity
              let currentObj = obj;
              while (currentObj) {
                if (currentObj.el && currentObj.el.classList.contains("expandable-banner")) {
                  // Trigger banner click
                  currentObj.el.dispatchEvent(new CustomEvent("click"));
                  return;
                }
                currentObj = currentObj.parent;
              }
            }
          });
          
          // Visual feedback - show distance to banners
          this.tick = () => {
            const banners = document.querySelectorAll(".expandable-banner");
            const handPos = new THREE.Vector3();
            hand.object3D.getWorldPosition(handPos);
            
            let closestBanner = null;
            let closestDist = Infinity;
            
            banners.forEach(banner => {
              if (!banner.object3D) return;
              
              const bannerPos = new THREE.Vector3();
              banner.object3D.getWorldPosition(bannerPos);
              const dist = handPos.distanceTo(bannerPos);
              
              if (dist < closestDist) {
                closestDist = dist;
                closestBanner = banner;
              }
            });
            
            // Highlight closest banner if within range
            banners.forEach(banner => {
              const bgEl = banner.querySelector("[position='0 0 -0.01']");
              if (bgEl && banner === closestBanner && closestDist < 2) {
                bgEl.setAttribute("material", "color: #000000; transparent: true; opacity: 1");
              } else if (bgEl) {
                bgEl.setAttribute("material", "color: #000000; transparent: true; opacity: 0.7");
              }
            });
          };
        }
      });

      // Spark splat component
      AFRAME.registerComponent("splat", {
        schema: { src: { default: "" } },
        init() {
          const splat = new SplatMesh({ url: this.data.src });
          splat.quaternion.set(1, 0, 0, 0);
          this.el.setObject3D("mesh", splat);
        }
      });

      // Spark renderer system
      AFRAME.registerSystem("splat", {
        init() {
          const sparkRenderer = new SparkRenderer({ renderer: this.el.renderer });
          this.sceneEl.object3D.add(sparkRenderer);
        }
      });

      // Simple grab component for VR controllers
      AFRAME.registerComponent("simple-grab", {
        init() {
          let heldObject = null;
          let originalRot = { x: 0, y: 0, z: 0 };
          let lastHandQuat = new THREE.Quaternion();
          let lastHandPos = new THREE.Vector3();
          let handVelocity = new THREE.Vector3();
          const hand = this.el;

          hand.addEventListener("triggerdown", (e) => {
            const handWorldPos = new THREE.Vector3();
            hand.object3D.getWorldPosition(handWorldPos);

            const grabbables = document.querySelectorAll("[grabbable]");
            let closest = null;
            let closestDist = 3;

            grabbables.forEach((obj) => {
              const objWorldPos = new THREE.Vector3();
              obj.object3D.getWorldPosition(objWorldPos);
              const dist = handWorldPos.distanceTo(objWorldPos);
              if (dist < closestDist) {
                closest = obj;
                closestDist = dist;
              }
            });

            if (closest) {
              heldObject = closest;
              // Store original rotation
              const rot = heldObject.getAttribute("rotation");
              originalRot = { x: rot.x, y: rot.y, z: rot.z };
              
              // Store initial position if not already stored
              if (!heldObject.hasAttribute("data-initial-pos")) {
                const pos = heldObject.getAttribute("position");
                heldObject.setAttribute("data-initial-pos", `${pos.x} ${pos.y} ${pos.z}`);
              }
              
              // Store initial rotation if not already stored
              if (!heldObject.hasAttribute("data-initial-rot")) {
                heldObject.setAttribute("data-initial-rot", `${rot.x} ${rot.y} ${rot.z}`);
              }
              
              // Store initial hand rotation
              hand.object3D.getWorldQuaternion(lastHandQuat);
              lastHandPos.copy(handWorldPos);
              handVelocity.set(0, 0, 0);
              
              heldObject.setAttribute("grabbed", true);
            }
          });

          hand.addEventListener("triggerup", (e) => {
            if (heldObject) {
              heldObject.removeAttribute("grabbed");
              
              // Only apply throw velocity to small objects (not the wheel)
              const isHeavyObject = heldObject.id === "potters-wheel";
              if (!isHeavyObject) {
                // Apply throw velocity to small objects
                heldObject.setAttribute("throw-velocity", handVelocity);
              } else {
                // For wheel, ensure it stays stable - clear any throw attributes
                heldObject.removeAttribute("throw-velocity");
              }
              
              heldObject = null;
            }
          });

          this.tick = function() {
            if (heldObject && heldObject.hasAttribute("grabbed")) {
              const handWorldPos = new THREE.Vector3();
              const handWorldQuat = new THREE.Quaternion();
              hand.object3D.getWorldPosition(handWorldPos);
              hand.object3D.getWorldQuaternion(handWorldQuat);

              // Calculate hand velocity
              handVelocity.subVectors(handWorldPos, lastHandPos).multiplyScalar(60); // 60 FPS normalization
              lastHandPos.copy(handWorldPos);

              const isHeavyObject = heldObject.id === "potters-wheel";
              
              if (isHeavyObject) {
                // For heavy objects like the wheel: maintain distance from user
                const camera = document.querySelector("[camera]");
                const cameraWorldPos = new THREE.Vector3();
                camera.object3D.getWorldPosition(cameraWorldPos);
                
                // Direction from camera to hand
                const directionToHand = new THREE.Vector3().subVectors(handWorldPos, cameraWorldPos).normalize();
                
                // Place wheel at distance from camera in the direction of the hand
                const wheelDistance = 1.5; // Distance from user
                const wheelWorldPos = new THREE.Vector3().addVectors(
                  cameraWorldPos,
                  directionToHand.multiplyScalar(wheelDistance)
                );
                
                // Convert to local position relative to wheel's parent
                const localWheelPos = new THREE.Vector3().copy(wheelWorldPos);
                const parent = heldObject.parentEl;
                
                if (parent && parent.object3D) {
                  parent.object3D.worldToLocal(localWheelPos);
                }
                
                const currentPos = heldObject.getAttribute("position");
                heldObject.setAttribute("position", {
                  x: localWheelPos.x,
                  y: currentPos.y, // Keep original height
                  z: localWheelPos.z
                });
              } else {
                // For small objects: follow hand exactly (convert to local position)
                const localHandPos = new THREE.Vector3().copy(handWorldPos);
                const parent = heldObject.parentEl;
                
                if (parent && parent.object3D) {
                  parent.object3D.worldToLocal(localHandPos);
                }
                
                heldObject.setAttribute("position", {
                  x: localHandPos.x,
                  y: localHandPos.y,
                  z: localHandPos.z
                });
              }

              // Calculate rotation delta
              const rotDelta = new THREE.Quaternion().multiplyQuaternions(
                handWorldQuat,
                lastHandQuat.clone().invert()
              );

              // Apply delta to object rotation
              const objRot = heldObject.getAttribute("rotation");
              const objQuat = new THREE.Quaternion();
              objQuat.setFromEuler(new THREE.Euler(
                objRot.x * Math.PI / 180,
                objRot.y * Math.PI / 180,
                objRot.z * Math.PI / 180
              ));

              // Rotate around object center
              objQuat.multiplyQuaternions(rotDelta, objQuat);
              
              let euler = new THREE.Euler().setFromQuaternion(objQuat);
              
              // For heavy objects, only allow Y rotation (revolving around vertical axis)
              if (isHeavyObject) {
                heldObject.setAttribute("rotation", {
                  x: originalRot.x, // Keep original X rotation
                  y: euler.y * 180 / Math.PI, // Only Y rotation allowed
                  z: originalRot.z // Keep original Z rotation
                });
              } else {
                // For small objects: allow full rotation
                heldObject.setAttribute("rotation", {
                  x: euler.x * 180 / Math.PI,
                  y: euler.y * 180 / Math.PI,
                  z: euler.z * 180 / Math.PI
                });
              }

              // Update last hand quaternion for next frame
              lastHandQuat.copy(handWorldQuat);
            }
          };
        }
      });

      // Throw component - applies velocity to thrown objects with reset after 2 seconds
      AFRAME.registerComponent("throw-velocity", {
        schema: { 
          x: { type: "number", default: 0 },
          y: { type: "number", default: 0 },
          z: { type: "number", default: 0 }
        },
        init() {
          this.velocity = new THREE.Vector3(this.data.x, this.data.y, this.data.z);
          this.gravity = -9.8;
          this.isThrown = true;
          this.throwTime = 0;
          this.throwDuration = 2; // 2 seconds before reset
          this.raycaster = new THREE.Raycaster();
          this.raycaster.far = 0.15; // Smaller detection range
          this.lastPos = new THREE.Vector3(0, 0, 0);
          this.checkCollisionCounter = 0;
          
          // Get initial position from stored data attribute
          const initialPosStr = this.el.getAttribute("data-initial-pos");
          if (initialPosStr) {
            const parts = initialPosStr.split(" ");
            this.originalPosition = { x: parseFloat(parts[0]), y: parseFloat(parts[1]), z: parseFloat(parts[2]) };
          } else {
            const pos = this.el.getAttribute("position");
            this.originalPosition = { x: pos.x, y: pos.y, z: pos.z };
          }
          
          // Get initial rotation from stored data attribute
          const initialRotStr = this.el.getAttribute("data-initial-rot");
          if (initialRotStr) {
            const parts = initialRotStr.split(" ");
            this.originalRotation = { x: parseFloat(parts[0]), y: parseFloat(parts[1]), z: parseFloat(parts[2]) };
          } else {
            const rot = this.el.getAttribute("rotation");
            this.originalRotation = { x: rot.x, y: rot.y, z: rot.z };
          }
        },
        tick(time, timeDelta) {
          if (this.isThrown) {
            this.throwTime += timeDelta;
            const deltaSeconds = timeDelta / 1000;
            const pos = this.el.getAttribute("position");
            
            // Check if 2 seconds have passed - reset object
            if (this.throwTime >= this.throwDuration * 1000) {
              this.el.setAttribute("position", this.originalPosition);
              this.el.setAttribute("rotation", this.originalRotation);
              this.isThrown = false;
              this.el.removeAttribute("throw-velocity");
              return;
            }
            
            // Apply velocity with better physics
            const prevY = pos.y;
            pos.x += this.velocity.x * deltaSeconds;
            pos.y += this.velocity.y * deltaSeconds + (this.gravity * deltaSeconds * deltaSeconds) / 2;
            pos.z += this.velocity.z * deltaSeconds;
            
            // Apply gravity
            this.velocity.y += this.gravity * deltaSeconds;
            
            // Only check collision every few frames to avoid getting stuck
            this.checkCollisionCounter++;
            if (this.checkCollisionCounter >= 3) {
              this.checkCollisionCounter = 0;
              
              const currentPos = new THREE.Vector3(pos.x, pos.y, pos.z);
              const scene = this.el.sceneEl.object3D;
              
              // Check collision downward only (for ground)
              const downDir = new THREE.Vector3(0, -1, 0);
              this.raycaster.set(currentPos, downDir);
              const downIntersects = this.raycaster.intersectObjects(scene.children, true);
              
              let groundCollision = false;
              for (let i = 0; i < downIntersects.length; i++) {
                const intersect = downIntersects[i];
                if (intersect.object === this.el.object3D || intersect.object.el === this.el) {
                  continue;
                }
                
                // Only stop downward movement on ground collision
                if (intersect.distance < 0.1 && this.velocity.y < 0) {
                  this.velocity.y = 0; // Stop falling
                  groundCollision = true;
                  break;
                }
              }
            }
            
            // Stop throwing if velocity is very low and falling
            const speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.z * this.velocity.z);
            if (speed < 0.01 && this.velocity.y < 0.1) {
              this.isThrown = false;
              this.el.removeAttribute("throw-velocity");
            }
            
            this.el.setAttribute("position", pos);
            this.lastPos.copy(new THREE.Vector3(pos.x, pos.y, pos.z));
          }
        }
      });

      // Overlay click-to-close handler
      document.getElementById("object-popup-overlay").addEventListener("click", () => {
        document.getElementById("object-popup").style.display = "none";
        document.getElementById("object-popup-overlay").style.display = "none";
      });

      // create scene AFTER everything is registered
      document.querySelector("#app").innerHTML = `
        <a-scene background="color: black" xr-mode-ui="enabled: true">

          <a-assets>
            <a-asset-item id="navmesh-glb" src="objects/Pottery_collider.glb"></a-asset-item>
          </a-assets>

          <!-- PLAYER (aframe-extras movement) -->
          <a-entity
            id="rig"
            position="0.362 0 0.496"
            rotation="0 47.561 0"
            movement-controls="speed: 0.1 ; constrainToNavMesh: true"
          >
            <a-entity camera look-controls position="0 2.5same 0" vr-popup-banner></a-entity>

            <a-entity id="leftHand" 
              oculus-touch-controls="hand: left"
              simple-grab
              hand-raycaster>
            </a-entity>
            <a-entity id="rightHand" 
              oculus-touch-controls="hand: right"
              simple-grab
              hand-raycaster>
            </a-entity>
          </a-entity>

          <!-- WORLD -->
          <a-entity
            id="world-container"
            position="0 -0.1 0"
            rotation="180 0 0"
            scale="2 2 2"
          >

<!-- NAVMESH (aframe-extras) -->
<a-entity 
gltf-model="objects/Pottery_collider.glb" 
visible="false" 
position="0 -2.76169 3.5693" 
scale="0.9 1 0.9">
</a-entity>

<!-- COLLIDER -->
<a-entity
gltf-model="#navmesh-glb"
visible="false"
></a-entity>

<!-- SPLAT -->
<a-entity
splat="src: objects/pottery.spz" 
scale="1 0.7 1">
</a-entity>

    <!-- POTTERY WHEEL AND VASE -->
    <a-entity id="wheel-container" position="-0.58 -0.5 0.58">
    <a-entity id="potters-wheel" 
    gltf-model="objects/potters_wheel.glb" 
    position="-0.0065 -0.04283 2.90938" 
    scale="0.9 0.9 0.9" 
    rotation="0 180 0"
    grabbable=""
    data-title="Potter's Wheel"
    data-description="The potter's wheel - push and pull to move it around, rotate to change its orientation.">
    </a-entity>
    </a-entity>

          </a-entity>

          </a-entity>

        <!-- GRABBABLE OBJECTS at scene root -->
<a-entity 
gltf-model="objects/ozolins_2_fake.glb" 
position="-2.74342 0.82753 0.7294" 
scale="0.4 0.4 0.4" 
grabbable="" id="obj1"
data-title="Ceramic Vase"
data-description="A beautiful handcrafted ceramic vase. Rotate to examine the intricate details and craftsmanship.">
</a-entity>

<a-entity 
gltf-model="objects/ceramic_vase_3d_Krievs.glb" 
position="-2.78748 0.88117 1.22016" 
scale="0.5 0.5 0.5" 
grabbable="" id="obj2"
data-title="Vase by Krievs"
data-description="An elegant pottery piece created by master craftsman Krievs. Notice the unique glaze patterns and smooth curves.">
</a-entity>

<a-entity 
gltf-model="objects/ceramic_jug_Dranda_2.glb" 
position="-2.92266 0.7591 1.72496" 
scale="0.35 0.35 0.3" 
grabbable="" id="obj3"
data-title="Ceramic Jug - Dranda Collection"
data-description="A traditional ceramic jug from the Dranda Collection. Examine the craftsmanship and unique handle design.">
</a-entity>

        </a-scene>
      `;

      // VR Button Handler
      document.getElementById("vr-button").addEventListener("click", () => {
        const scene = document.querySelector("a-scene");
        scene.enterVR();
      });

      // Hide welcome text when entering VR
      document.querySelector("a-scene").addEventListener("enter-vr", () => {
        document.getElementById("welcome-text").style.display = "none";
      });

      // Show welcome text when exiting VR
      document.querySelector("a-scene").addEventListener("exit-vr", () => {
        document.getElementById("welcome-text").style.display = "block";
      });
    </script>
  </body>
</html>